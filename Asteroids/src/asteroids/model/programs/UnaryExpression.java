package asteroids.model.programs;import be.kuleuven.cs.som.annotate.*;/** * A class of unary arithmetic expressions. *   A unary expression involves a single operator applied *   to a single operand. *  * @version  2.0 * @author   Eric Steegmans */public abstract class UnaryExpression extends ComposedExpression {	/**	 * Initialize this new unary expression with given operand.	 *	 * @param  operand	 *         The operand for this new unary expression.	 * @post   The operand for this new unary expression is the	 *         same as the given operand.	 *       | new.getOperand() == operand	 * @throws IllegalOperandException	 *         This new unary expression cannot have the given	 *         operand as its operand at index 1.	 *       | ! canHaveAsOperandAt(operand,1)	 */	@Model	protected UnaryExpression(Expression operand, int line, int column) {		super(line, column);		if (!canHaveAsOperandAt(operand,1))			throw new IllegalArgumentException(this + "" + operand);		setOperandAt(1, operand);	}	/**	 * Return the number of operands involved in this unary expression.	 *	 * @return A unary expression always involves a single operand.	 *       | result == 1	 */	@Override	@Basic	public final int getNbOperands() {		return 1;	}	/**	 * Return the operand of this unary expression at the given index.	 * 	 * @return The one and only operand of this unary expression.	 *       | result == getOperand()	 */	@Override	public final Expression getOperandAt(int index)			throws IndexOutOfBoundsException {		if (index != 1)			throw new IndexOutOfBoundsException();		return getOperand();	}	/**	 * Return the operand of this unary expression.	 */	@Basic	public Expression getOperand() {		return operand;	}		/**	 * Check whether this unary expression can have the given	 * expression as its operand at the given index.	 *	 * @return True if and only if the given expression is effective,	 *         and if that expression does not have this composed	 *         expression as a subexpression, and if the given	 *         index is 1.	 *       | result ==	 *       |    ( (expression != null) &&	 *       |      (! expression.hasAsSubExpression(this)) &&	 *       |      (index == 1) )	 */	@Override	public boolean canHaveAsOperandAt(Expression expression, int index) {		return super.canHaveAsOperandAt(expression, index) && (index == 1);	}	/**	 * Set the operand for this unary expression at the given	 * index to the given operand.	 */	@Override	protected void setOperandAt(int index, Expression operand) {		this.operand = operand;	}	/**	 * Variable referencing the operand of this unary expression.	 * 	 * @note    This variable is not qualified final, such that operands	 *          can be changed in cloning unary expressions.	 */	private Expression operand;	/**	 * Return a textual representation of this unary expression.	 *	 * @return If the operand of this unary expression is a basic expression,	 *         the symbol representing the operator of this unary	 *         expression followed by the textual representation of	 *         the operand of this unary expression.	 *       | if (getOperand() instanceof BasicExpression)	 *       |   then result.equals	 *       |          (getOperator() + getOperand().toString())	 * @return If the operand of this unary expression is a composed expression,	 *         the symbol representing the operator of this unary	 *         expression followed by the textual representation of	 *         the operand of this unary expression in paranthesis.	 *       | if (getOperand() instanceof ComposedExpression)	 *       |   then result.equals	 *       |          (getOperator() + "(" + getOperand().toString() + ")")	 */	@Override	public String toString() {		if (getOperand() instanceof BasicExpression)			return getOperatorSymbol() + getOperand().toString();		if (getOperand() instanceof ComposedExpression)			return getOperatorSymbol() + "(" + getOperand().toString() + ")";		throw new Error("Unknown expression type!");	}}