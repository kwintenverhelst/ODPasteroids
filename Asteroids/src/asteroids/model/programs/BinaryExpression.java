package asteroids.model.programs;import be.kuleuven.cs.som.annotate.*;/** * A class of binary arithmetic expressions. *   A binary expression involves a single operator applied *   to a left-hand operand and a right-hand operand. *  * @version  2.0 * @author   Eric Steegmans */public abstract class BinaryExpression extends ComposedExpression {	/**	 * Initialize this new binary expression with given operands.	 *	 * @param  left	 *         The left operand for this new binary expression.	 * @param  right	 *         The right operand for this new binary expression.	 * @post   The left operand of this new binary expression is the	 *         same as the given left operand.	 *       | new.getLeftOperand() == left	 * @post   The right operand of this new binary expression is the	 *         same as the given right operand.	 *       | new.getRightOperand() == right	 * @throws IllegalOperandException	 *         This new binary expression cannot have the given left	 *         operand or the given right operand as its operands at	 *         the corresponding positions.	 *      |     (! canHaveAsOperandAt(left,1))	 *      |  || (! canHaveAsOperandAt(right,2))	 */	@Model	protected BinaryExpression(Expression left, Expression right, int line, int column) {		super(line, column);		//if (!canHaveAsOperandAt(left,1))			//throw new IllegalArgumentException(this + " left");		//if (!canHaveAsOperandAt(right,2))			//throw new IllegalArgumentException(this + " right");		setOperandAt(1, left);		setOperandAt(2, right);	}	/**	 * Return the number of operands involved in this binary expression.	 *	 * @return A binary expression always involves two operands.	 *       | result == 2	 */	@Override	@Basic	public final int getNbOperands() {		return 2;	}	/**	 * Return the operand of this binary expression at the given index.	 * 	 * @return If the given index is 1, the left operand of this	 *         binary expression; otherwise the right operand of	 *         this binary expression.	 *       | if (index == 1)	 *       |   then result == getLeftOperand()	 *       |   else result == getRightOperand()	 */	@Override	@Raw	public final Expression getOperandAt(int index)			throws IndexOutOfBoundsException {		if ((index != 1) && (index != 2))			throw new IndexOutOfBoundsException();		if (index == 1)			return getLeftOperand();		else			return getRightOperand();	}		/**	 * Check whether this binary expression can have the given	 * expression as its operand at the given index.	 *	 * @return True if and only if the given expression is effective,	 *         and if that expression does not have this composed	 *         expression as a subexpression, and if the given	 *         index is either 1 or 2.	 *       | result ==	 *       |    ( (expression != null) &&	 *       |      (! expression.hasAsSubExpression(this)) &&	 *       |      ( (index == 1) || (index == 2) ) )	 */	@Override	public boolean canHaveAsOperandAt(Expression expression, int index) {		return super.canHaveAsOperandAt(expression, index) && ( (index == 1) || (index == 2) );	}	/**	 * Set the operand for this binary expression at the given	 * index to the given operand.	 */	@Override	@Raw	protected void setOperandAt(int index, Expression operand) {		if (index == 1)			this.leftOperand = operand;		else			this.rightOperand = operand;	}	/**	 * Return the left operand of this binary expression.	 */	@Basic	public Expression getLeftOperand() {		return leftOperand;	}	/**	 * Variable referencing the left operand of this	 * binary expression.	 *	 * @note   This variable is not qualified final, such that operands	 *         can be changed in cloning unary expressions.	 */	private Expression leftOperand;	/**	 * Return the right operand of this binary expression.	 */	@Basic	public Expression getRightOperand() {		return rightOperand;	}	/**	 * Variable referencing the right operand of this	 * binary expression.	 *	 * @note   This variable is not qualified final, such that operands	 *         can be changed in cloning unary expressions.	 */	private Expression rightOperand;	/**	 * Return a textual representation of this binary expression.	 *	 * @return If both operands of this binary expression are basic expressions,	 *         the textual representation of the left operand of this binary	 *         expression, followed by the symbol representing the operator	 *         of this binary expression followed by the textual representation	 *         of the right operand of this binary expression.	 *       | if ( (getLeftOperand() instanceof BasicExpression) &&	 *       |      (getRightOperand() instanceof BasicExpression) )	 *       |   then result.equals	 *       |          (getLeftOperand().toString() + getOperator() +	 *       |           getRightOperand().toString())	 * @return If the left operand of this binary expression is a basic expression	 *         and the right operand of this binary expression is a composed expression,	 *         the textual representation of the left operand of this binary	 *         expression, followed by the symbol representing the operator	 *         of this binary expression followed by the textual representation	 *         of the right operand of this binary expression in parenthesis.	 *       | if ( (getLeftOperand() instanceof BasicExpression) &&	 *       |      (getRightOperand() instanceof ComposedExpression) )	 *       |   then result.equals	 *       |          (getLeftOperand().toString() + getOperator() +	 *       |           "(" + getRightOperand().toString() + ")")	 * @return If the left operand of this binary expression is a composed expression	 *         and the right operand of this binary expression is a basic expression,	 *         the textual representation of the left operand of this binary	 *         expression in parenthesis, followed by the symbol representing the operator	 *         of this binary expression followed by the textual representation	 *         of the right operand of this binary expression.	 *       | if ( (getLeftOperand() instanceof ComposedExpression) &&	 *       |      (getRightOperand() instanceof BasicExpression) )	 *       |   then result.equals	 *       |          ("(" + getLeftOperand().toString() + ")" + getOperator() +	 *       |           getRightOperand().toString())	 * @return If both operands of this binary expression are composed expressions,	 *         the textual representation of the left operand of this binary	 *         expression in parenthesis, followed by the symbol representing the operator	 *         of this binary expression followed by the textual representation	 *         of the right operand of this binary expression in parenthesis.	 *       | if ( (getLeftOperand() instanceof ComposedExpression) &&	 *       |      (getRightOperand() instanceof ComposedExpression) )	 *       |   then result.equals	 *       |          ("(" + getLeftOperand().toString() + ")" + getOperator() +	 *       |           "(" + getRightOperand().toString() + ")")	 * @note   In the specification of this method, we assume that the classification of	 *         expressions into basic expressions and composed expressions is total. This	 *         means that we assume that no other kinds of expressions will ever be	 *         introduced next to basic expressions and composed expressions.	 */	@Override	public String toString() {		String result;		if (getLeftOperand() instanceof BasicExpression)			result = getLeftOperand().toString();		else if (getLeftOperand() instanceof ComposedExpression)			result = "(" + getLeftOperand().toString() + ")";		else			throw new Error("Unknown expression type!");		result += getOperatorSymbol();		if (getRightOperand() instanceof BasicExpression)			result += getRightOperand().toString();		else if (getRightOperand() instanceof ComposedExpression)			result += "(" + getRightOperand().toString() + ")";		else			throw new Error("Unknown expression type!");		return result;	}}